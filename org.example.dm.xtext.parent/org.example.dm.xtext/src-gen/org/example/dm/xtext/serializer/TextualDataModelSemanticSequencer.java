/*
 * generated by Xtext 2.35.0
 */
package org.example.dm.xtext.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.example.dm.Attribute;
import org.example.dm.BooleanType;
import org.example.dm.DataModel;
import org.example.dm.DateTimeType;
import org.example.dm.DateType;
import org.example.dm.DmPackage;
import org.example.dm.Entity;
import org.example.dm.Localization;
import org.example.dm.NumericType;
import org.example.dm.Relationship;
import org.example.dm.RelationshipEnd;
import org.example.dm.StringType;
import org.example.dm.UuidType;
import org.example.dm.xtext.services.TextualDataModelGrammarAccess;

@SuppressWarnings("all")
public class TextualDataModelSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private TextualDataModelGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == DmPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case DmPackage.ATTRIBUTE:
				sequence_Attribute(context, (Attribute) semanticObject); 
				return; 
			case DmPackage.BOOLEAN_TYPE:
				sequence_BooleanType(context, (BooleanType) semanticObject); 
				return; 
			case DmPackage.DATA_MODEL:
				sequence_DataModel(context, (DataModel) semanticObject); 
				return; 
			case DmPackage.DATE_TIME_TYPE:
				sequence_DateTimeType(context, (DateTimeType) semanticObject); 
				return; 
			case DmPackage.DATE_TYPE:
				sequence_DateType(context, (DateType) semanticObject); 
				return; 
			case DmPackage.ENTITY:
				sequence_Entity(context, (Entity) semanticObject); 
				return; 
			case DmPackage.LOCALIZATION:
				sequence_Localization(context, (Localization) semanticObject); 
				return; 
			case DmPackage.NUMERIC_TYPE:
				sequence_NumericType(context, (NumericType) semanticObject); 
				return; 
			case DmPackage.RELATIONSHIP:
				sequence_Relationship(context, (Relationship) semanticObject); 
				return; 
			case DmPackage.RELATIONSHIP_END:
				sequence_RelationshipEnd(context, (RelationshipEnd) semanticObject); 
				return; 
			case DmPackage.STRING_TYPE:
				sequence_StringType(context, (StringType) semanticObject); 
				return; 
			case DmPackage.UUID_TYPE:
				sequence_UuidType(context, (UuidType) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     Attribute returns Attribute
	 *
	 * Constraint:
	 *     (
	 *         name=ElementName 
	 *         dataType=[DataType|ElementName] 
	 *         lower=INT 
	 *         upper=UnlimitedNatural 
	 *         identity?='[id]'? 
	 *         defaultValue=Text? 
	 *         description=Text? 
	 *         localizations+=Localization*
	 *     )
	 * </pre>
	 */
	protected void sequence_Attribute(ISerializationContext context, Attribute semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     DataType returns BooleanType
	 *     BooleanType returns BooleanType
	 *
	 * Constraint:
	 *     (name=ElementName description=Text? localizations+=Localization*)
	 * </pre>
	 */
	protected void sequence_BooleanType(ISerializationContext context, BooleanType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     DataModel returns DataModel
	 *
	 * Constraint:
	 *     (
	 *         name=ElementName 
	 *         description=Text? 
	 *         locales+=ID* 
	 *         localizations+=Localization* 
	 *         entities+=Entity* 
	 *         relationships+=Relationship* 
	 *         dataTypes+=DataType*
	 *     )
	 * </pre>
	 */
	protected void sequence_DataModel(ISerializationContext context, DataModel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     DataType returns DateTimeType
	 *     DateTimeType returns DateTimeType
	 *
	 * Constraint:
	 *     (name=ElementName description=Text? localizations+=Localization*)
	 * </pre>
	 */
	protected void sequence_DateTimeType(ISerializationContext context, DateTimeType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     DataType returns DateType
	 *     DateType returns DateType
	 *
	 * Constraint:
	 *     (name=ElementName description=Text? localizations+=Localization*)
	 * </pre>
	 */
	protected void sequence_DateType(ISerializationContext context, DateType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Entity returns Entity
	 *
	 * Constraint:
	 *     (
	 *         name=ElementName 
	 *         kind=EntityKind? 
	 *         generals+=[Entity|ElementName]* 
	 *         description=Text? 
	 *         localizations+=Localization* 
	 *         attributes+=Attribute*
	 *     )
	 * </pre>
	 */
	protected void sequence_Entity(ISerializationContext context, Entity semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Localization returns Localization
	 *
	 * Constraint:
	 *     (locale=ID (name=Text description=Text?)?)
	 * </pre>
	 */
	protected void sequence_Localization(ISerializationContext context, Localization semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     DataType returns NumericType
	 *     NumericType returns NumericType
	 *
	 * Constraint:
	 *     (
	 *         name=ElementName 
	 *         description=Text? 
	 *         localizations+=Localization* 
	 *         size=PositiveShort? 
	 *         totalDigits=PositiveShort? 
	 *         fractionDigits=PositiveShort? 
	 *         minInclusive=Double? 
	 *         minExclusive=Double? 
	 *         maxInclusive=Double? 
	 *         maxExclusive=Double? 
	 *         measurementUnit=Text?
	 *     )
	 * </pre>
	 */
	protected void sequence_NumericType(ISerializationContext context, NumericType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     RelationshipEnd returns RelationshipEnd
	 *
	 * Constraint:
	 *     (
	 *         name=ElementName? 
	 *         entity=[Entity|ElementName] 
	 *         lower=INT 
	 *         upper=UnlimitedNatural 
	 *         description=Text? 
	 *         localizations+=Localization*
	 *     )
	 * </pre>
	 */
	protected void sequence_RelationshipEnd(ISerializationContext context, RelationshipEnd semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Relationship returns Relationship
	 *
	 * Constraint:
	 *     (name=ElementName? kind=RelationshipKind? description=Text? localizations+=Localization* ends+=RelationshipEnd*)
	 * </pre>
	 */
	protected void sequence_Relationship(ISerializationContext context, Relationship semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     DataType returns StringType
	 *     StringType returns StringType
	 *
	 * Constraint:
	 *     (
	 *         name=ElementName 
	 *         description=Text? 
	 *         localizations+=Localization* 
	 *         length=INT? 
	 *         minLength=INT? 
	 *         maxLength=INT? 
	 *         pattern=Text?
	 *     )
	 * </pre>
	 */
	protected void sequence_StringType(ISerializationContext context, StringType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     DataType returns UuidType
	 *     UuidType returns UuidType
	 *
	 * Constraint:
	 *     (name=ElementName description=Text? localizations+=Localization*)
	 * </pre>
	 */
	protected void sequence_UuidType(ISerializationContext context, UuidType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
